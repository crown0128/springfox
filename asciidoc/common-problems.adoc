== Answers to common questions and problems

*Q. Why does springfox ignore the http status code in the return value of a controller method?*

A. https://github.com/springfox/springfox/issues/822[Reference #822]

*Q. What is the relationship between swagger-ui and springfox-swagger-ui?*

A. It can be a little confusing :open_mouth:

- Swagger Spec is a specification
- Swagger Api - an implementation of that specification that supports jax-rs, restlet, jersey etc.
- Springfox libraries in general - is another implementation of the specification focused on the spring based ecosystem
- Swagger.js and Swagger-ui - Are client libraries in javascript that can consume swagger specification
- springfox-swagger-ui - the one that you're referring to, is just packaging swagger-ui in a convenient way so that
spring services can serve it up.

*Q. I use GSON and don't use Jackson, What should I do?*

A. Thanks to https://github.com/chrishuttonch[@chrishuttonch] for describing the solution to https://github.com/springfox/springfox/issues/867[this issue]

TIP: I switched on the excludeFieldsWithoutExposeAnnotation() which meant that none of the objects would produce any data. To get around this I created several serialisers for the following classes:

[source,java]
----
.registerTypeAdapter(springfox.documentation.service.ApiListing.class, new SwaggerApiListingJsonSerializer())
.registerTypeAdapter(springfox.documentation.spring.web.json.Json.class, new SwaggerJsonSerializer())
.registerTypeAdapter(springfox.documentation.swagger.web.SwaggerResource.class, new SwaggerResourceSerializer())
.registerTypeAdapter(springfox.documentation.service.ResourceListing.class, new SwaggerResourceListingJsonSerializer())
.registerTypeAdapter(springfox.documentation.swagger.web.SwaggerResource.class, new SwaggerResourceSerializer())
.registerTypeAdapter(springfox.documentation.swagger.web.SecurityConfiguration.class, new SwaggerSecurityConfigurationSerializer())
.registerTypeAdapter(springfox.documentation.swagger.web.UiConfiguration.class, new SwaggerUiConfigurationSerializer());
----

*Q. I get an NPE during application startup in a spring-boot app?*

A. Thanks to https://github.com/shasti421[@shasti421] for providing the solution

TIP: Running in debugger revealed that i had two instances of WebApplicationInitializers in my war. Spring is
refreshing context with each one and is resulting in second instance of OptimizedModelPropertiesProvider without
onApplicationEvent call. I was able to fix it by removing second WebApplicationInitializer in my code. Seems  this is
 related to https://github.com/spring-projects/spring-boot/issues/221[spring-boot issue #221]

*Q. How do we use Java 8 types esply. LocalDateTime?*

A. Typically these are handled via `Docket#directModelSubstitute(LocalDateTime.class, String.class)`. If these
are ISO 8601 dates that conform to a string format i.e. `yyyy-MM-dd'T'HH:mm'Z'`. However you won't have any format or
 validation info.

*Q. How does one use @ModelAttribute annotation. It doesn't seem to render the model properties as scalar properties?*

In order for @ModelAttribute annotated types to be inferred the properties need to be bean properties.
Couple of observations

If the intent is immutability and passing in an object, the preferred approach is to make that a request body, in which
case the immutability will follow the rules laid out by jackson to determine what constitutes a request "view" of the
request object.

getters/setters are a clean way to indicate what values can come in to a operation. While it may not be apparent in a
trivial model with one level nesting; the design choice will become clear when we realize that model attributes can be
arbitrarily nested. Consider (pseudo code in c# for brevity)

```c#
Person {String firstName {get;set;}, String lastName {get;set;}, Category category {get;set;}}
Category {String name {get;set;}, String description {get;}}
```

So one could set properties
firstName
lastName
category.name

Now we don't want category to be able to set description via the operation, how do we control/specify that?

it makes it hard to reason about which fields in an objects are not intended to be mutated. This is the reason we chose
to limit it to objects that expose getters and setters.

NOTE: I know spring supports fields as well, and it will fall back to fields if setters are not found

*Q. How should we resolve multiple object mappers available as beans especially when using spring-hateoas?*

The idea is to provide a `@Primary` ObjectMapper.

Based on answer provided by @prabhat1790 in [issue #890](https://github.com/springfox/springfox/issues/890)
```java
  private static final String SPRING_HATEOAS_OBJECT_MAPPER = "_halObjectMapper";

  @Autowired
  @Qualifier(SPRING_HATEOAS_OBJECT_MAPPER)
  private ObjectMapper springHateoasObjectMapper;

  @Primary
  @Bean
  @Order(value=Ordered.HIGHEST_PRECEDENCE)
  @DependsOn(SPRING_HATEOAS_OBJECT_MAPPER)
  public ObjectMapper objectMapper() {
    return springHateoasObjectMapper;
  }
```
and set the order of the other bean to lowest precedence